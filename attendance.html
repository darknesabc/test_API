<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>출결 상세</title>
  <link rel="stylesheet" href="styles.css" />
  <style>
    .att-wrap { overflow:auto; border:1px solid rgba(255,255,255,0.08); border-radius:12px; }
    table.att { border-collapse: collapse; width: max-content; min-width: 100%; }
    table.att th, table.att td {
      padding: 10px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      border-right: 1px solid rgba(255,255,255,0.06);
      white-space: nowrap;
      text-align: left;
      vertical-align: middle;
    }
    table.att th { border-bottom: 1px solid rgba(255,255,255,0.12); }

    .sticky-top { position: sticky; top: 0; z-index: 5; background: rgba(10,16,30,0.96); }
    .sticky-left { position: sticky; left: 0; z-index: 6; background: rgba(10,16,30,0.92); }
    .sticky-corner { position: sticky; top:0; left:0; z-index: 7; background: rgba(10,16,30,0.98); }

    .day-head { font-weight: 900; letter-spacing: 0.2px; }
    .sub-head { font-size: 12px; color: rgba(255,255,255,0.75); margin-top: 2px; }

    .col-period { min-width: 56px; text-align: center; }
    .col-sched { min-width: 160px; max-width: 240px; overflow: hidden; text-overflow: ellipsis; }
    .col-status { min-width: 84px; text-align: center; font-weight: 900; }

    .status-present { background: rgba(120,255,170,0.18); border-right: 1px solid rgba(120,255,170,0.12); }
    .status-absent  { background: rgba(255,120,120,0.18); border-right: 1px solid rgba(255,120,120,0.12); }
    .status-empty   { color: rgba(255,255,255,0.5); }

    .sched-text { color: rgba(255,255,255,0.90); }
    .sched-muted { color: rgba(255,255,255,0.65); font-size: 12px; }

    .summary-box{
      margin: 12px 0 14px;
      padding: 12px 14px;
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      background: rgba(255,255,255,0.04);
    }
    .summary-title{ font-weight: 900; margin-bottom: 6px; }
    .summary-line{ color: rgba(255,255,255,0.88); }
    .summary-sub{ margin-top: 6px; color: rgba(255,255,255,0.75); font-size: 13px; }
  </style>
</head>

<body data-needs-login="1">
  <header class="topbar">
    <div class="topbar-inner">
      <div>
        <div class="top-title">출결 상세</div>
        <div id="titleLine" class="top-sub"></div>
      </div>
      <a class="btn btn-ghost" href="dashboard.html">대시보드</a>
    </div>
  </header>

  <main class="wrap">
    <section class="card">
      <h2 class="card-title">출결 기록</h2>
      <p id="loading" class="muted">불러오는 중...</p>
      <p id="err" class="msg"></p>

      <div class="summary-box" id="weeklySummary" style="display:none;">
        <div class="summary-title">이번 주 출결 요약</div>
        <div class="summary-line" id="sumCounts"></div>
        <div class="summary-sub" id="sumRecent"></div>
        <div class="summary-sub" style="opacity:.85;">
          * 결석은 “스케줄 공란 + 결석”만 집계됩니다. (오늘 기준, 미래 제외)
        </div>
      </div>

      <div class="att-wrap">
        <table class="att">
          <thead id="thead"></thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>

      <p class="muted" style="margin-top:10px;">
        * 날짜별로 [스케줄 | 출/결] 두 칸으로 표시됩니다.
      </p>
    </section>
  </main>

  <script src="script.js"></script>
  <script>
    function attText(a) {
      const s = String(a ?? "").trim();
      if (s === "1") return "출석";
      if (s === "3") return "결석";
      return "";
    }

    // ✅ dates가 "문자열"이든 "객체({md,dow,iso})"든 통일해서 쓰기
    function normalizeDates(datesRaw) {
      const dayMap = {
        Mon: "월", Tue: "화", Wed: "수", Thu: "목", Fri: "금", Sat: "토", Sun: "일",
        월: "월", 화: "화", 수: "수", 목: "목", 금: "금", 토: "토", 일: "일"
      };

      return (datesRaw || []).map(d => {
        // 객체 형태
        if (d && typeof d === "object") {
          const md = String(d.md ?? "").trim();   // "2/2"
          const dow = String(d.dow ?? "").trim(); // "월"
          const iso = String(d.iso ?? "").trim(); // "2026-02-02"
          return { md, dow: (dayMap[dow] || dow), iso };
        }

        // 문자열 형태: "2/2 (Mon)" 같은 기존 포맷
        const s = String(d ?? "").trim();
        const m = s.match(/^(.+?)\s*\((.+?)\)\s*$/);
        if (m) {
          const md = m[1].trim();
          const dow = (dayMap[m[2]] || m[2]);
          return { md, dow, iso: "" };
        }
        // "2/2"만 있는 경우
        return { md: s, dow: "", iso: "" };
      });
    }

    function statusClass(status) {
      if (status === "출석") return "status-present";
      if (status === "결석") return "status-absent";
      return "status-empty";
    }

    function parseIso(iso) {
      const [y,m,d] = String(iso).split("-").map(Number);
      return new Date(y, m-1, d);
    }

    function mondayOf(d) {
      const x = new Date(d);
      const day = x.getDay(); // 0=Sun..6=Sat
      const diff = (day === 0 ? -6 : 1 - day);
      x.setDate(x.getDate() + diff);
      x.setHours(0,0,0,0);
      return x;
    }

    // ✅ 결석 카운트 조건: 스케줄 공란 + 결석만
    function isCountedAbsence(schedule, statusText) {
      if (statusText !== "결석") return false;
      return String(schedule ?? "").trim() === "";
    }

    function buildWeeklySummary(data, datesNorm) {
      const box = document.getElementById("weeklySummary");
      const sumCounts = document.getElementById("sumCounts");
      const sumRecent = document.getElementById("sumRecent");

      const rows = data.rows || [];
      const todayIso = data.todayIso || "";

      if (!datesNorm.length || !rows.length || !todayIso) return;

      const today = parseIso(todayIso);
      today.setHours(0,0,0,0);

      // 이번 주: 오늘이 속한 주(월~일)
      const weekStart = mondayOf(today);
      const weekEnd = new Date(weekStart); weekEnd.setDate(weekStart.getDate() + 6);

      // 이번 주 + 오늘(미래 제외) 컬럼만 선택 (iso가 있을 때만 정확히 필터)
      const weekIdx = [];
      datesNorm.forEach((d, i) => {
        if (!d.iso) return;
        const dd = parseIso(d.iso);
        dd.setHours(0,0,0,0);
        if (dd >= weekStart && dd <= weekEnd && dd <= today) weekIdx.push(i);
      });

      if (!weekIdx.length) return;

      let present = 0;
      let absent = 0;
      const absEvents = []; // {idx, period}

      for (const r of rows) {
        const period = r.period || "";
        const cells = r.cells || [];

        for (const i of weekIdx) {
          const cell = cells[i] || {};
          const sched = String(cell.s ?? "").trim();
          const status = attText(cell.a);

          if (status === "출석") present++;

          if (isCountedAbsence(sched, status)) {
            absent++;
            absEvents.push({ idx: i, period });
          }
        }
      }

      // 최근 결석: 오늘 기준 과거 중 최신(인덱스가 뒤일수록 최근이라고 가정)
      absEvents.sort((a,b) => b.idx - a.idx);
      const top2 = absEvents.slice(0, 2);

      sumCounts.textContent = `출석 ${present}회 · 결석 ${absent}회`;

      if (top2.length === 0) {
        sumRecent.textContent = `최근 결석: 없음`;
      } else {
        const parts = top2.map(x => `${datesNorm[x.idx].md}(${datesNorm[x.idx].dow}) ${x.period}교시`);
        sumRecent.textContent = `최근 결석: ${parts.join(", ")}`;
      }

      box.style.display = "";
    }

    // ==============================
    // ✅ 이동 데이터로 스케줄 공백 채우기
    // ==============================

    // move_detail의 date 포맷이 무엇이든 ISO(YYYY-MM-DD)로 정규화
    function normalizeMoveDateToIso(dateVal) {
      const s = String(dateVal ?? "").trim();
      if (!s) return "";

      // 이미 ISO
      if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;

      // "2026. 2. 10" / "2026.2.10" / "2026/2/10" 등
      let m = s.match(/(\d{4})\D+(\d{1,2})\D+(\d{1,2})/);
      if (m) {
        const y = m[1];
        const mm = String(m[2]).padStart(2, "0");
        const dd = String(m[3]).padStart(2, "0");
        return `${y}-${mm}-${dd}`;
      }

      // "02/10" 같은 md 형태만 오는 경우는 attendance의 iso가 없으면 매칭 불가(일단 빈값)
      return "";
    }

    // 이동 기록을 map[iso][period] = reason 으로 변환
    function buildMoveMap(moveItems) {
      const map = {}; // { [iso]: { [period]: reason } }

      for (const it of (moveItems || [])) {
        const iso = normalizeMoveDateToIso(it.date);
        const reason = String(it.reason ?? "").trim();
        const rp = Number(it.returnPeriod ?? 0); // 복귀교시

        if (!iso || !reason || !rp) continue;

        map[iso] ||= {};

        // ✅ 룰: 복귀교시 rp이면 (rp-1)~rp 교시에 reason 채움
        const from = Math.max(1, rp - 1);
        const to = rp;
        for (let p = from; p <= to; p++) {
          map[iso][p] = reason;
        }
      }
      return map;
    }

    // attendance 그리드의 스케줄 공백만 이동 사유로 채움
    function applyMoveToAttendance(attData, datesNorm, moveMap) {
      const rows = attData.rows || [];
      const isoByIdx = (datesNorm || []).map(d => String(d.iso || "").trim());

      for (const r of rows) {
        const periodNum = Number(r.period || 0);
        const cells = r.cells || [];

        for (let i = 0; i < cells.length; i++) {
          const iso = isoByIdx[i];
          if (!iso) continue;

          const c = cells[i] || {};
          const sched = String(c.s ?? "").trim();

          // ✅ 공백(또는 "-")만 채우기
          const isEmptySched = (sched === "" || sched === "-");
          if (!isEmptySched) continue;

          const reason = moveMap?.[iso]?.[periodNum];
          if (reason) {
            c.s = reason;
            cells[i] = c;
          }
        }
        r.cells = cells;
      }

      attData.rows = rows;
      return attData;
    }

    (async function () {
      const raw = sessionStorage.getItem("parent_session_v1");
      const session = raw ? JSON.parse(raw) : null;
      if (!session) return;

      document.getElementById("titleLine").textContent =
        `${session.studentName} (${session.seat || ""}${session.teacher ? " · " + session.teacher + " 담임" : ""})`;

      const loading = document.getElementById("loading");
      const err = document.getElementById("err");
      const thead = document.getElementById("thead");
      const tbody = document.getElementById("tbody");

      try {
        // 1) 출결 상세 가져오기
        const res = await fetch(`${API_BASE}?path=attendance`, {
          method: "POST",
          headers: { "Content-Type": "text/plain;charset=utf-8" },
          body: JSON.stringify({ token: session.token })
        });

        const data = await res.json();
        if (!data.ok) throw new Error(data.error || "불러오기 실패");

        const datesNorm = normalizeDates(data.dates);
        const rows = data.rows || [];

        // 2) 이동 상세도 가져와서(표 범위에 맞춰) 스케줄 공백 채우기
        //    - attendance가 iso를 주는 경우에만 정확히 매칭됨
        //    - days는 넉넉하게 60일로 (원하면 더 줄여도 됨)
        try {
          const moveRes = await fetch(`${API_BASE}?path=move_detail`, {
            method: "POST",
            headers: { "Content-Type": "text/plain;charset=utf-8" },
            body: JSON.stringify({ token: session.token, days: 60 })
          });
          const moveData = await moveRes.json();

          if (moveData && moveData.ok) {
            const moveMap = buildMoveMap(moveData.items || []);
            applyMoveToAttendance(data, datesNorm, moveMap);
          }
        } catch (_) {
          // 이동 불러오기 실패해도 출결 표는 정상 출력되게 그냥 무시
        }

        loading.textContent = "";

        // ✅ 이번 주 요약(오늘 기준 미래 제외) - "이동 사유로 채운 스케줄" 반영됨
        buildWeeklySummary(data, datesNorm);

        // ===== 헤더(2행) =====
        const topCells = datesNorm.map(d => {
          return `
            <th class="sticky-top day-head" colspan="2">
              <div>${d.md || ""}</div>
              <div class="sub-head">${d.dow || ""}</div>
            </th>
          `;
        }).join("");

        const subCells = datesNorm.map(() => `
          <th class="sticky-top sub-head">스케줄</th>
          <th class="sticky-top sub-head">출/결</th>
        `).join("");

        thead.innerHTML = `
          <tr>
            <th class="sticky-corner sticky-top col-period">교시</th>
            ${topCells}
          </tr>
          <tr>
            <th class="sticky-corner sticky-top col-period"></th>
            ${subCells}
          </tr>
        `;

        if (rows.length === 0) {
          tbody.innerHTML = `<tr><td style="padding:10px;">기록이 없습니다.</td></tr>`;
          return;
        }

        // ===== 바디 =====
        tbody.innerHTML = rows.map(r => {
          const tds = (r.cells || []).map(cell => {
            const sched = String(cell?.s ?? "").trim();
            const status = attText(cell?.a);
            const cls = statusClass(status);

            const schedHtml = sched
              ? `<div class="sched-text" title="${sched}">${sched}</div>`
              : `<div class="sched-muted"> </div>`;

            const statusHtml = status ? status : "-";

            return `
              <td class="col-sched">${schedHtml}</td>
              <td class="col-status ${cls}">${statusHtml}</td>
            `;
          }).join("");

          return `
            <tr>
              <td class="sticky-left col-period">${r.period || ""}</td>
              ${tds}
            </tr>
          `;
        }).join("");

      } catch (e) {
        loading.textContent = "";
        err.textContent = e.message || String(e);
      }
    })();
  </script>
</body>
</html>
